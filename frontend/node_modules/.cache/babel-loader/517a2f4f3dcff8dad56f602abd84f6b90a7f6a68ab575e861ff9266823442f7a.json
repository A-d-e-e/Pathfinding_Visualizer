{"ast":null,"code":"var _jsxFileName = \"D:\\\\Projects\\\\Pathfinder\\\\pathfinding-visualizer\\\\frontend\\\\src\\\\App.jsx\",\n  _s = $RefreshSig$();\n// src/App.jsx\nimport React, { useState, useEffect, useRef } from 'react'; // ← added useRef\nimport Controls from './components/Controls';\nimport Node from './components/Node';\nimport { dfs, bfs, dijkstra, astar } from './algorithms';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App() {\n  _s();\n  const rows = 20,\n    cols = 30;\n  const [grid, setGrid] = useState([]);\n  const [algorithm, setAlgorithm] = useState('DFS');\n  const [speed, setSpeed] = useState(50);\n  const [startCoord, setStartCoord] = useState('0,0');\n  const [endCoord, setEndCoord] = useState(`${rows - 1},${cols - 1}`);\n  const [statusMap, setStatusMap] = useState({});\n  const timeoutsRef = useRef([]); // ← track timeouts\n\n  // 1) initialize grid\n  useEffect(() => {\n    const g = Array.from({\n      length: rows\n    }, (_, r) => Array.from({\n      length: cols\n    }, (_, c) => ({\n      row: r,\n      col: c,\n      isWall: false\n    })));\n    setGrid(g);\n  }, []);\n\n  // toggle wall on click\n  const toggleWall = (r, c) => {\n    setGrid(g => {\n      const g2 = g.map(row => row.map(c => ({\n        ...c\n      })));\n      g2[r][c].isWall = !g2[r][c].isWall;\n      return g2;\n    });\n  };\n\n  // 2) random walls with BFS connectivity check\n  const generateWalls = () => {\n    let attempt = 0,\n      maxAttempts = 10;\n    const tryGen = () => {\n      setGrid(g => g.map(row => row.map(c => ({\n        ...c,\n        isWall: Math.random() < 0.3\n      }))));\n      // after DOM & state update, test connectivity\n      setTimeout(() => {\n        // parse coords for BFS test\n        let sr, sc, er, ec;\n        try {\n          [sr, sc] = parseCoord(startCoord);\n          [er, ec] = parseCoord(endCoord);\n        } catch {\n          return;\n        }\n        const {\n          path\n        } = bfs({\n          grid,\n          start: {\n            r: sr,\n            c: sc\n          },\n          end: {\n            r: er,\n            c: ec\n          }\n        });\n        if (path.length === 0 && attempt < maxAttempts) {\n          attempt++;\n          tryGen(); // retry if no path found\n        } else if (path.length === 0) {\n          alert('Could not generate walls without blocking path.');\n        }\n      }, 0);\n    };\n    tryGen();\n  };\n\n  // clear all status & walls\n  const resetGrid = () => {\n    // clear any running timeouts\n    timeoutsRef.current.forEach(id => clearTimeout(id));\n    timeoutsRef.current = [];\n    setStatusMap({});\n    setGrid(g => g.map(row => row.map(c => ({\n      ...c,\n      isWall: false\n    }))));\n  };\n\n  // 3) robust parse \"r,c\" → [r,c]\n  const parseCoord = str => {\n    const parts = str.split(',').map(s => s.trim()); // trim whitespace \n    const r = Number.parseInt(parts[0], 10);\n    const c = Number.parseInt(parts[1], 10);\n    if (Number.isNaN(r) || Number.isNaN(c)) {\n      throw new Error(`Invalid coordinate: \"${str}\"`);\n    }\n    return [r, c];\n  };\n\n  // run and animate\n  const visualize = () => {\n    // clear any prior animation\n    timeoutsRef.current.forEach(id => clearTimeout(id));\n    timeoutsRef.current = [];\n    setStatusMap({});\n\n    // parse & validate start/end\n    let sr, sc, er, ec;\n    try {\n      [sr, sc] = parseCoord(startCoord);\n      [er, ec] = parseCoord(endCoord);\n    } catch (err) {\n      alert(err.message);\n      return;\n    }\n    if (sr < 0 || sr >= rows || sc < 0 || sc >= cols || er < 0 || er >= rows || ec < 0 || ec >= cols) {\n      alert('Start/end coordinates out of bounds');\n      return;\n    }\n\n    // pick algorithm\n    const algoFn = ({\n      grid,\n      start,\n      end\n    }) => {\n      switch (algorithm) {\n        case 'BFS':\n          return bfs({\n            grid,\n            start,\n            end\n          });\n        case 'Dijkstra':\n          return dijkstra({\n            grid,\n            start,\n            end\n          });\n        case 'AStar':\n          return astar({\n            grid,\n            start,\n            end\n          });\n        default:\n          return dfs({\n            grid,\n            start,\n            end\n          });\n      }\n    };\n    const {\n      visitedOrder,\n      path\n    } = algoFn({\n      grid,\n      start: {\n        r: sr,\n        c: sc\n      },\n      end: {\n        r: er,\n        c: ec\n      }\n    });\n\n    // animate visited nodes\n    visitedOrder.forEach(({\n      r,\n      c\n    }, i) => {\n      const id = setTimeout(() => {\n        setStatusMap(m => ({\n          ...m,\n          [`${r}-${c}`]: 'visited'\n        }));\n      }, speed * i);\n      timeoutsRef.current.push(id); // ← track :contentReference[oaicite:2]{index=2}\n    });\n\n    // animate final path\n    const delay = speed * visitedOrder.length;\n    path.forEach(({\n      r,\n      c\n    }, i) => {\n      const id = setTimeout(() => {\n        setStatusMap(m => ({\n          ...m,\n          [`${r}-${c}`]: 'path'\n        }));\n      }, delay + speed * i);\n      timeoutsRef.current.push(id);\n    });\n\n    // mark start & end immediately\n    setStatusMap(m => ({\n      ...m,\n      [`${sr}-${sc}`]: 'start',\n      [`${er}-${ec}`]: 'end'\n    }));\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [/*#__PURE__*/_jsxDEV(Controls, {\n      algorithm: algorithm,\n      setAlgorithm: setAlgorithm,\n      speed: speed,\n      setSpeed: setSpeed,\n      startCoord: startCoord,\n      setStartCoord: setStartCoord,\n      endCoord: endCoord,\n      setEndCoord: setEndCoord,\n      generateWalls: generateWalls,\n      resetGrid: resetGrid,\n      visualize: visualize,\n      stop: () => {\n        // ← pass Stop handler\n        timeoutsRef.current.forEach(id => clearTimeout(id));\n        timeoutsRef.current = [];\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid.map((row, ri) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map(cell => /*#__PURE__*/_jsxDEV(Node, {\n          cell: cell,\n          onToggleWall: toggleWall,\n          status: statusMap[`${cell.row}-${cell.col}`]\n        }, `${cell.row}-${cell.col}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 172,\n          columnNumber: 15\n        }, this))\n      }, ri, false, {\n        fileName: _jsxFileName,\n        lineNumber: 170,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 153,\n    columnNumber: 5\n  }, this);\n}\n_s(App, \"l/5xLDIxKgXzVlgl9LeZ5ho1kkY=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useRef","Controls","Node","dfs","bfs","dijkstra","astar","jsxDEV","_jsxDEV","App","_s","rows","cols","grid","setGrid","algorithm","setAlgorithm","speed","setSpeed","startCoord","setStartCoord","endCoord","setEndCoord","statusMap","setStatusMap","timeoutsRef","g","Array","from","length","_","r","c","row","col","isWall","toggleWall","g2","map","generateWalls","attempt","maxAttempts","tryGen","Math","random","setTimeout","sr","sc","er","ec","parseCoord","path","start","end","alert","resetGrid","current","forEach","id","clearTimeout","str","parts","split","s","trim","Number","parseInt","isNaN","Error","visualize","err","message","algoFn","visitedOrder","i","m","push","delay","className","children","stop","fileName","_jsxFileName","lineNumber","columnNumber","ri","cell","onToggleWall","status","_c","$RefreshReg$"],"sources":["D:/Projects/Pathfinder/pathfinding-visualizer/frontend/src/App.jsx"],"sourcesContent":["// src/App.jsx\r\nimport React, { useState, useEffect, useRef } from 'react';            // ← added useRef\r\nimport Controls from './components/Controls';\r\nimport Node from './components/Node';\r\nimport { dfs, bfs, dijkstra, astar } from './algorithms';\r\n\r\nexport default function App() {\r\n  const rows = 20, cols = 30;\r\n  const [grid, setGrid] = useState([]);\r\n  const [algorithm, setAlgorithm] = useState('DFS');\r\n  const [speed, setSpeed] = useState(50);\r\n  const [startCoord, setStartCoord] = useState('0,0');\r\n  const [endCoord, setEndCoord] = useState(`${rows-1},${cols-1}`);\r\n  const [statusMap, setStatusMap] = useState({}); \r\n  const timeoutsRef = useRef([]);                                 // ← track timeouts\r\n\r\n  // 1) initialize grid\r\n  useEffect(() => {\r\n    const g = Array.from({ length: rows }, (_, r) =>\r\n      Array.from({ length: cols }, (_, c) => ({ row: r, col: c, isWall: false }))\r\n    );\r\n    setGrid(g);\r\n  }, []);\r\n\r\n  // toggle wall on click\r\n  const toggleWall = (r, c) => {\r\n    setGrid(g => {\r\n      const g2 = g.map(row => row.map(c => ({ ...c })));\r\n      g2[r][c].isWall = !g2[r][c].isWall;\r\n      return g2;\r\n    });\r\n  };\r\n\r\n  // 2) random walls with BFS connectivity check\r\n  const generateWalls = () => {\r\n    let attempt = 0, maxAttempts = 10;\r\n    const tryGen = () => {\r\n      setGrid(g =>\r\n        g.map(row =>\r\n          row.map(c => ({ ...c, isWall: Math.random() < 0.3 }))\r\n        )\r\n      );\r\n      // after DOM & state update, test connectivity\r\n      setTimeout(() => {\r\n        // parse coords for BFS test\r\n        let sr, sc, er, ec;\r\n        try {\r\n          [sr, sc] = parseCoord(startCoord);\r\n          [er, ec] = parseCoord(endCoord);\r\n        } catch {\r\n          return; \r\n        }\r\n        const { path } = bfs({\r\n          grid,\r\n          start: { r: sr, c: sc },\r\n          end:   { r: er, c: ec }\r\n        });\r\n        if (path.length === 0 && attempt < maxAttempts) {\r\n          attempt++;\r\n          tryGen();    // retry if no path found\r\n        } else if (path.length === 0) {\r\n          alert('Could not generate walls without blocking path.');\r\n        }\r\n      }, 0);\r\n    };\r\n    tryGen();\r\n  };\r\n\r\n  // clear all status & walls\r\n  const resetGrid = () => {\r\n    // clear any running timeouts\r\n    timeoutsRef.current.forEach(id => clearTimeout(id));\r\n    timeoutsRef.current = [];\r\n    setStatusMap({});\r\n    setGrid(g => g.map(row => row.map(c => ({ ...c, isWall: false }))));\r\n  };\r\n\r\n  // 3) robust parse \"r,c\" → [r,c]\r\n  const parseCoord = str => {\r\n    const parts = str.split(',').map(s => s.trim());               // trim whitespace \r\n    const r = Number.parseInt(parts[0], 10);\r\n    const c = Number.parseInt(parts[1], 10);\r\n    if (Number.isNaN(r) || Number.isNaN(c)) {\r\n      throw new Error(`Invalid coordinate: \"${str}\"`);\r\n    }\r\n    return [r, c];\r\n  };\r\n\r\n  // run and animate\r\n  const visualize = () => {\r\n    // clear any prior animation\r\n    timeoutsRef.current.forEach(id => clearTimeout(id));\r\n    timeoutsRef.current = [];\r\n    setStatusMap({});\r\n\r\n    // parse & validate start/end\r\n    let sr, sc, er, ec;\r\n    try {\r\n      [sr, sc] = parseCoord(startCoord);\r\n      [er, ec] = parseCoord(endCoord);\r\n    } catch (err) {\r\n      alert(err.message);\r\n      return;\r\n    }\r\n    if (\r\n      sr<0||sr>=rows||sc<0||sc>=cols||\r\n      er<0||er>=rows||ec<0||ec>=cols\r\n    ) {\r\n      alert('Start/end coordinates out of bounds');\r\n      return;\r\n    }\r\n\r\n    // pick algorithm\r\n    const algoFn = ({grid,start,end}) => {\r\n      switch(algorithm) {\r\n        case 'BFS':      return bfs({grid,start,end});\r\n        case 'Dijkstra': return dijkstra({grid,start,end});\r\n        case 'AStar':    return astar({grid,start,end});\r\n        default:         return dfs({grid,start,end});\r\n      }\r\n    };\r\n\r\n    const { visitedOrder, path } = algoFn({\r\n      grid, start:{r:sr,c:sc}, end:{r:er,c:ec}\r\n    });\r\n\r\n    // animate visited nodes\r\n    visitedOrder.forEach(({r,c}, i) => {\r\n      const id = setTimeout(() => {\r\n        setStatusMap(m => ({ ...m, [`${r}-${c}`]:'visited' }));\r\n      }, speed * i);\r\n      timeoutsRef.current.push(id);                                // ← track :contentReference[oaicite:2]{index=2}\r\n    });\r\n\r\n    // animate final path\r\n    const delay = speed * visitedOrder.length;\r\n    path.forEach(({r,c}, i) => {\r\n      const id = setTimeout(() => {\r\n        setStatusMap(m => ({ ...m, [`${r}-${c}`]:'path' }));\r\n      }, delay + speed * i);\r\n      timeoutsRef.current.push(id);\r\n    });\r\n\r\n    // mark start & end immediately\r\n    setStatusMap(m => ({\r\n      ...m,\r\n      [`${sr}-${sc}`]:'start',\r\n      [`${er}-${ec}`]:'end'\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <div className=\"app\">\r\n      <Controls\r\n        algorithm={algorithm} setAlgorithm={setAlgorithm}\r\n        speed={speed} setSpeed={setSpeed}\r\n        startCoord={startCoord} setStartCoord={setStartCoord}\r\n        endCoord={endCoord} setEndCoord={setEndCoord}\r\n        generateWalls={generateWalls}\r\n        resetGrid={resetGrid}\r\n        visualize={visualize}\r\n        stop={() => {                                            // ← pass Stop handler\r\n          timeoutsRef.current.forEach(id => clearTimeout(id));\r\n          timeoutsRef.current = [];\r\n        }}\r\n      />\r\n\r\n      <div className=\"grid\">\r\n        {grid.map((row, ri) => (\r\n          <div key={ri} className=\"grid-row\">\r\n            {row.map(cell => (\r\n              <Node\r\n                key={`${cell.row}-${cell.col}`}\r\n                cell={cell}\r\n                onToggleWall={toggleWall}\r\n                status={statusMap[`${cell.row}-${cell.col}`]}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}