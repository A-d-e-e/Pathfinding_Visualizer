{"ast":null,"code":"// src/algorithms.js\n\n// ── BFS ───────────────────────────────────────────────────────────────────────\nexport function bfs({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const q = [];\n  const visitedOrder = [];\n  q.push(start);\n  visited[start.r][start.c] = true;\n  while (q.length) {\n    const {\n      r,\n      c\n    } = q.shift();\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        visited[nr][nc] = true;\n        prev[nr][nc] = {\n          r,\n          c\n        };\n        q.push({\n          r: nr,\n          c: nc\n        });\n      }\n    }\n  }\n  const path = [];\n  let cur = (visited[end.r] || [])[end.c] ? end : null;\n  while (cur) {\n    var _prev$cur$r;\n    path.unshift(cur);\n    cur = (_prev$cur$r = prev[cur.r]) === null || _prev$cur$r === void 0 ? void 0 : _prev$cur$r[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── DFS (recursive, early-stop) ───────────────────────────────────────────────\nexport function dfs({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const visitedOrder = [];\n  let found = false;\n  function recurse(r, c) {\n    if (found || visited[r][c]) return; // abort if goal found \n    visited[r][c] = true;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) {\n      found = true;\n      return;\n    }\n    for (const [dr, dc] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        prev[nr][nc] = {\n          r,\n          c\n        };\n        recurse(nr, nc);\n        if (found) return; // stop siblings once found\n      }\n    }\n  }\n  recurse(start.r, start.c);\n  const path = [];\n  if (visited[end.r][end.c]) {\n    let cur = end;\n    while (cur) {\n      var _prev$cur$r2;\n      path.unshift(cur);\n      cur = (_prev$cur$r2 = prev[cur.r]) === null || _prev$cur$r2 === void 0 ? void 0 : _prev$cur$r2[cur.c];\n    }\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── DIJKSTRA (early-exit) ─────────────────────────────────────────────────────\nexport function dijkstra({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const dist = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const visitedOrder = [];\n  dist[start.r][start.c] = 0;\n  outer: while (true) {\n    // label for early break :contentReference[oaicite:2]{index=2}\n    let min = Infinity,\n      u = null;\n    for (let r = 0; r < R; r++) {\n      for (let c = 0; c < C; c++) {\n        if (!visited[r][c] && dist[r][c] < min) {\n          min = dist[r][c];\n          u = {\n            r,\n            c\n          };\n        }\n      }\n    }\n    if (!u) break;\n    const {\n      r,\n      c\n    } = u;\n    visited[r][c] = true;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break outer; // stop entire loop on target :contentReference[oaicite:3]{index=3}\n\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        const alt = dist[r][c] + 1;\n        if (alt < dist[nr][nc]) {\n          dist[nr][nc] = alt;\n          prev[nr][nc] = {\n            r,\n            c\n          };\n        }\n      }\n    }\n  }\n  const path = [];\n  let cur = dist[end.r][end.c] < Infinity ? end : null;\n  while (cur) {\n    var _prev$cur$r3;\n    path.unshift(cur);\n    cur = (_prev$cur$r3 = prev[cur.r]) === null || _prev$cur$r3 === void 0 ? void 0 : _prev$cur$r3[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── A* SEARCH ─────────────────────────────────────────────────────────────────\nfunction heuristic(a, b) {\n  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);\n}\nexport function astar({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const gScore = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const fScore = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const visitedOrder = [];\n  gScore[start.r][start.c] = 0;\n  fScore[start.r][start.c] = heuristic(start, end);\n  const openSet = [start];\n  const inOpen = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  inOpen[start.r][start.c] = true;\n  while (openSet.length) {\n    let idx = 0;\n    for (let i = 1; i < openSet.length; i++) {\n      const u = openSet[i],\n        best = openSet[idx];\n      if (fScore[u.r][u.c] < fScore[best.r][best.c]) idx = i;\n    }\n    const {\n      r,\n      c\n    } = openSet.splice(idx, 1)[0];\n    inOpen[r][c] = false;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !grid[nr][nc].isWall) {\n        const tentativeG = gScore[r][c] + 1;\n        if (tentativeG < gScore[nr][nc]) {\n          prev[nr][nc] = {\n            r,\n            c\n          };\n          gScore[nr][nc] = tentativeG;\n          fScore[nr][nc] = tentativeG + heuristic({\n            r: nr,\n            c: nc\n          }, end);\n          if (!inOpen[nr][nc]) {\n            openSet.push({\n              r: nr,\n              c: nc\n            });\n            inOpen[nr][nc] = true;\n          }\n        }\n      }\n    }\n  }\n  const path = [];\n  let cur = fScore[end.r][end.c] < Infinity ? end : null;\n  while (cur) {\n    var _prev$cur$r4;\n    path.unshift(cur);\n    cur = (_prev$cur$r4 = prev[cur.r]) === null || _prev$cur$r4 === void 0 ? void 0 : _prev$cur$r4[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}","map":{"version":3,"names":["bfs","grid","start","end","R","length","C","visited","Array","from","fill","prev","q","visitedOrder","push","r","c","shift","dr","dc","nr","nc","isWall","path","cur","_prev$cur$r","unshift","dfs","found","recurse","_prev$cur$r2","dijkstra","dist","Infinity","outer","min","u","alt","_prev$cur$r3","heuristic","a","b","Math","abs","astar","gScore","fScore","openSet","inOpen","idx","i","best","splice","tentativeG","_prev$cur$r4"],"sources":["D:/Projects/Pathfinder/pathfinding-visualizer/frontend/src/algorithms.js"],"sourcesContent":["// src/algorithms.js\r\n\r\n// ── BFS ───────────────────────────────────────────────────────────────────────\r\nexport function bfs({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const q = [];\r\n    const visitedOrder = [];\r\n  \r\n    q.push(start);\r\n    visited[start.r][start.c] = true;\r\n  \r\n    while (q.length) {\r\n      const { r, c } = q.shift();\r\n      visitedOrder.push({ r, c });\r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          visited[nr][nc] = true;\r\n          prev[nr][nc] = { r, c };\r\n          q.push({ r: nr, c: nc });\r\n        }\r\n      }\r\n    }\r\n  \r\n    const path = [];\r\n    let cur = (visited[end.r]||[])[end.c] ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── DFS (recursive, early-stop) ───────────────────────────────────────────────\r\n  export function dfs({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const visitedOrder = [];\r\n    let found = false;\r\n  \r\n    function recurse(r, c) {\r\n      if (found || visited[r][c]) return;                    // abort if goal found \r\n      visited[r][c] = true;\r\n      visitedOrder.push({ r, c });\r\n      if (r === end.r && c === end.c) { found = true; return; }\r\n  \r\n      for (const [dr, dc] of [[0,-1],[0,1],[-1,0],[1,0]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          prev[nr][nc] = { r, c };\r\n          recurse(nr, nc);\r\n          if (found) return;                                  // stop siblings once found\r\n        }\r\n      }\r\n    }\r\n  \r\n    recurse(start.r, start.c);\r\n  \r\n    const path = [];\r\n    if (visited[end.r][end.c]) {\r\n      let cur = end;\r\n      while (cur) {\r\n        path.unshift(cur);\r\n        cur = prev[cur.r]?.[cur.c];\r\n      }\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── DIJKSTRA (early-exit) ─────────────────────────────────────────────────────\r\n  export function dijkstra({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const dist    = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const visitedOrder = [];\r\n  \r\n    dist[start.r][start.c] = 0;\r\n  \r\n    outer: while (true) {                                     // label for early break :contentReference[oaicite:2]{index=2}\r\n      let min = Infinity, u = null;\r\n      for (let r = 0; r < R; r++) {\r\n        for (let c = 0; c < C; c++) {\r\n          if (!visited[r][c] && dist[r][c] < min) {\r\n            min = dist[r][c];\r\n            u = { r, c };\r\n          }\r\n        }\r\n      }\r\n      if (!u) break;\r\n      const { r, c } = u;\r\n      visited[r][c] = true;\r\n      visitedOrder.push({ r, c });\r\n  \r\n      if (r === end.r && c === end.c) break outer;            // stop entire loop on target :contentReference[oaicite:3]{index=3}\r\n  \r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          const alt = dist[r][c] + 1;\r\n          if (alt < dist[nr][nc]) {\r\n            dist[nr][nc] = alt;\r\n            prev[nr][nc] = { r, c };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    const path = [];\r\n    let cur = dist[end.r][end.c] < Infinity ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── A* SEARCH ─────────────────────────────────────────────────────────────────\r\n  function heuristic(a, b) {\r\n    return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);\r\n  }\r\n  \r\n  export function astar({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const gScore = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const fScore = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const prev   = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const visitedOrder = [];\r\n  \r\n    gScore[start.r][start.c] = 0;\r\n    fScore[start.r][start.c] = heuristic(start, end);\r\n  \r\n    const openSet = [ start ];\r\n    const inOpen  = Array.from({ length: R }, () => Array(C).fill(false));\r\n    inOpen[start.r][start.c] = true;\r\n  \r\n    while (openSet.length) {\r\n      let idx = 0;\r\n      for (let i = 1; i < openSet.length; i++) {\r\n        const u = openSet[i], best = openSet[idx];\r\n        if (fScore[u.r][u.c] < fScore[best.r][best.c]) idx = i;\r\n      }\r\n      const { r, c } = openSet.splice(idx, 1)[0];\r\n      inOpen[r][c] = false;\r\n      visitedOrder.push({ r, c });\r\n  \r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          const tentativeG = gScore[r][c] + 1;\r\n          if (tentativeG < gScore[nr][nc]) {\r\n            prev[nr][nc] = { r, c };\r\n            gScore[nr][nc] = tentativeG;\r\n            fScore[nr][nc] = tentativeG + heuristic({ r: nr, c: nc }, end);\r\n            if (!inOpen[nr][nc]) {\r\n              openSet.push({ r: nr, c: nc });\r\n              inOpen[nr][nc] = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    const path = [];\r\n    let cur = fScore[end.r][end.c] < Infinity ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}