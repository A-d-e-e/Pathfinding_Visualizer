{"ast":null,"code":"// src/algorithms.js\n\n// ── BFS ───────────────────────────────────────────────────────────────────────\nexport function bfs({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const q = [];\n  const visitedOrder = [];\n\n  // init\n  q.push(start);\n  visited[start.r][start.c] = true;\n\n  // explore\n  while (q.length) {\n    const {\n      r,\n      c\n    } = q.shift();\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        visited[nr][nc] = true;\n        prev[nr][nc] = {\n          r,\n          c\n        };\n        q.push({\n          r: nr,\n          c: nc\n        });\n      }\n    }\n  }\n\n  // build path\n  const path = [];\n  let cur = (visited[end.r] || [])[end.c] ? end : null;\n  while (cur) {\n    var _prev$cur$r;\n    path.unshift(cur);\n    cur = (_prev$cur$r = prev[cur.r]) === null || _prev$cur$r === void 0 ? void 0 : _prev$cur$r[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── DFS ───────────────────────────────────────────────────────────────────────\nexport function dfs({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const stack = [];\n  const visitedOrder = [];\n  stack.push(start);\n  // Note: mark visited when popped to reflect actual exploration order\n  while (stack.length) {\n    const {\n      r,\n      c\n    } = stack.pop();\n    if (visited[r][c]) continue;\n    visited[r][c] = true;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n\n    // push neighbors in reverse order if you want up,down,left,right\n    for (const [dr, dc] of [[0, -1], [0, 1], [-1, 0], [1, 0]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        prev[nr][nc] = {\n          r,\n          c\n        };\n        stack.push({\n          r: nr,\n          c: nc\n        });\n      }\n    }\n  }\n\n  // reconstruct path\n  const path = [];\n  let cur = (visited[end.r] || [])[end.c] ? end : null;\n  while (cur) {\n    var _prev$cur$r2;\n    path.unshift(cur);\n    cur = (_prev$cur$r2 = prev[cur.r]) === null || _prev$cur$r2 === void 0 ? void 0 : _prev$cur$r2[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── DIJKSTRA ──────────────────────────────────────────────────────────────────\nexport function dijkstra({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const dist = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const visited = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  const visitedOrder = [];\n  dist[start.r][start.c] = 0;\n  while (true) {\n    // find unvisited node with smallest dist\n    let min = Infinity,\n      u = null;\n    for (let r = 0; r < R; r++) {\n      for (let c = 0; c < C; c++) {\n        if (!visited[r][c] && dist[r][c] < min) {\n          min = dist[r][c];\n          u = {\n            r,\n            c\n          };\n        }\n      }\n    }\n    if (!u) break;\n    const {\n      r,\n      c\n    } = u;\n    visited[r][c] = true;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n\n    // relax neighbors\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !visited[nr][nc] && !grid[nr][nc].isWall) {\n        const alt = dist[r][c] + 1;\n        if (alt < dist[nr][nc]) {\n          dist[nr][nc] = alt;\n          prev[nr][nc] = {\n            r,\n            c\n          };\n        }\n      }\n    }\n  }\n\n  // reconstruct path\n  const path = [];\n  let cur = dist[end.r][end.c] < Infinity ? end : null;\n  while (cur) {\n    var _prev$cur$r3;\n    path.unshift(cur);\n    cur = (_prev$cur$r3 = prev[cur.r]) === null || _prev$cur$r3 === void 0 ? void 0 : _prev$cur$r3[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}\n\n// ── A* SEARCH ─────────────────────────────────────────────────────────────────\nfunction heuristic(a, b) {\n  // Manhattan distance\n  return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);\n}\nexport function astar({\n  grid,\n  start,\n  end\n}) {\n  const R = grid.length,\n    C = grid[0].length;\n  const gScore = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const fScore = Array.from({\n    length: R\n  }, () => Array(C).fill(Infinity));\n  const prev = Array.from({\n    length: R\n  }, () => Array(C).fill(null));\n  const visitedOrder = [];\n  gScore[start.r][start.c] = 0;\n  fScore[start.r][start.c] = heuristic(start, end);\n\n  // open set as array\n  const openSet = [start];\n  const inOpen = Array.from({\n    length: R\n  }, () => Array(C).fill(false));\n  inOpen[start.r][start.c] = true;\n  while (openSet.length) {\n    // get node in openSet with lowest fScore\n    let idx = 0;\n    for (let i = 1; i < openSet.length; i++) {\n      const u = openSet[i],\n        best = openSet[idx];\n      if (fScore[u.r][u.c] < fScore[best.r][best.c]) idx = i;\n    }\n    const {\n      r,\n      c\n    } = openSet.splice(idx, 1)[0];\n    inOpen[r][c] = false;\n    visitedOrder.push({\n      r,\n      c\n    });\n    if (r === end.r && c === end.c) break;\n    for (const [dr, dc] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {\n      const nr = r + dr,\n        nc = c + dc;\n      if (nr >= 0 && nr < R && nc >= 0 && nc < C && !grid[nr][nc].isWall) {\n        const tentativeG = gScore[r][c] + 1;\n        if (tentativeG < gScore[nr][nc]) {\n          prev[nr][nc] = {\n            r,\n            c\n          };\n          gScore[nr][nc] = tentativeG;\n          fScore[nr][nc] = tentativeG + heuristic({\n            r: nr,\n            c: nc\n          }, end);\n          if (!inOpen[nr][nc]) {\n            openSet.push({\n              r: nr,\n              c: nc\n            });\n            inOpen[nr][nc] = true;\n          }\n        }\n      }\n    }\n  }\n\n  // reconstruct path\n  const path = [];\n  let cur = fScore[end.r][end.c] < Infinity ? end : null;\n  while (cur) {\n    var _prev$cur$r4;\n    path.unshift(cur);\n    cur = (_prev$cur$r4 = prev[cur.r]) === null || _prev$cur$r4 === void 0 ? void 0 : _prev$cur$r4[cur.c];\n  }\n  return {\n    visitedOrder,\n    path\n  };\n}","map":{"version":3,"names":["bfs","grid","start","end","R","length","C","visited","Array","from","fill","prev","q","visitedOrder","push","r","c","shift","dr","dc","nr","nc","isWall","path","cur","_prev$cur$r","unshift","dfs","stack","pop","_prev$cur$r2","dijkstra","dist","Infinity","min","u","alt","_prev$cur$r3","heuristic","a","b","Math","abs","astar","gScore","fScore","openSet","inOpen","idx","i","best","splice","tentativeG","_prev$cur$r4"],"sources":["D:/Projects/pathfinding-visualizer/frontend/src/algorithms.js"],"sourcesContent":["// src/algorithms.js\r\n\r\n// ── BFS ───────────────────────────────────────────────────────────────────────\r\nexport function bfs({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const q = [];\r\n    const visitedOrder = [];\r\n  \r\n    // init\r\n    q.push(start);\r\n    visited[start.r][start.c] = true;\r\n  \r\n    // explore\r\n    while (q.length) {\r\n      const { r, c } = q.shift();\r\n      visitedOrder.push({ r, c });\r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          visited[nr][nc] = true;\r\n          prev[nr][nc] = { r, c };\r\n          q.push({ r: nr, c: nc });\r\n        }\r\n      }\r\n    }\r\n  \r\n    // build path\r\n    const path = [];\r\n    let cur = (visited[end.r]||[])[end.c] ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── DFS ───────────────────────────────────────────────────────────────────────\r\n  export function dfs({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const stack = [];\r\n    const visitedOrder = [];\r\n  \r\n    stack.push(start);\r\n    // Note: mark visited when popped to reflect actual exploration order\r\n    while (stack.length) {\r\n      const { r, c } = stack.pop();\r\n      if (visited[r][c]) continue;\r\n      visited[r][c] = true;\r\n      visitedOrder.push({ r, c });\r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      // push neighbors in reverse order if you want up,down,left,right\r\n      for (const [dr, dc] of [[0,-1],[0,1],[-1,0],[1,0]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          prev[nr][nc] = { r, c };\r\n          stack.push({ r: nr, c: nc });\r\n        }\r\n      }\r\n    }\r\n  \r\n    // reconstruct path\r\n    const path = [];\r\n    let cur = (visited[end.r]||[])[end.c] ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── DIJKSTRA ──────────────────────────────────────────────────────────────────\r\n  export function dijkstra({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const dist    = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const prev    = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const visited = Array.from({ length: R }, () => Array(C).fill(false));\r\n    const visitedOrder = [];\r\n  \r\n    dist[start.r][start.c] = 0;\r\n  \r\n    while (true) {\r\n      // find unvisited node with smallest dist\r\n      let min = Infinity, u = null;\r\n      for (let r = 0; r < R; r++) {\r\n        for (let c = 0; c < C; c++) {\r\n          if (!visited[r][c] && dist[r][c] < min) {\r\n            min = dist[r][c];\r\n            u = { r, c };\r\n          }\r\n        }\r\n      }\r\n      if (!u) break;\r\n      const { r, c } = u;\r\n      visited[r][c] = true;\r\n      visitedOrder.push({ r, c });\r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      // relax neighbors\r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !visited[nr][nc] &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          const alt = dist[r][c] + 1;\r\n          if (alt < dist[nr][nc]) {\r\n            dist[nr][nc] = alt;\r\n            prev[nr][nc] = { r, c };\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // reconstruct path\r\n    const path = [];\r\n    let cur = dist[end.r][end.c] < Infinity ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  \r\n  // ── A* SEARCH ─────────────────────────────────────────────────────────────────\r\n  function heuristic(a, b) {\r\n    // Manhattan distance\r\n    return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);\r\n  }\r\n  \r\n  export function astar({ grid, start, end }) {\r\n    const R = grid.length, C = grid[0].length;\r\n    const gScore = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const fScore = Array.from({ length: R }, () => Array(C).fill(Infinity));\r\n    const prev   = Array.from({ length: R }, () => Array(C).fill(null));\r\n    const visitedOrder = [];\r\n  \r\n    gScore[start.r][start.c] = 0;\r\n    fScore[start.r][start.c] = heuristic(start, end);\r\n  \r\n    // open set as array\r\n    const openSet = [ start ];\r\n    const inOpen  = Array.from({ length: R }, () => Array(C).fill(false));\r\n    inOpen[start.r][start.c] = true;\r\n  \r\n    while (openSet.length) {\r\n      // get node in openSet with lowest fScore\r\n      let idx = 0;\r\n      for (let i = 1; i < openSet.length; i++) {\r\n        const u = openSet[i], best = openSet[idx];\r\n        if (fScore[u.r][u.c] < fScore[best.r][best.c]) idx = i;\r\n      }\r\n      const { r, c } = openSet.splice(idx, 1)[0];\r\n      inOpen[r][c] = false;\r\n      visitedOrder.push({ r, c });\r\n  \r\n      if (r === end.r && c === end.c) break;\r\n  \r\n      for (const [dr, dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {\r\n        const nr = r + dr, nc = c + dc;\r\n        if (\r\n          nr >= 0 && nr < R && nc >= 0 && nc < C &&\r\n          !grid[nr][nc].isWall\r\n        ) {\r\n          const tentativeG = gScore[r][c] + 1;\r\n          if (tentativeG < gScore[nr][nc]) {\r\n            prev[nr][nc] = { r, c };\r\n            gScore[nr][nc] = tentativeG;\r\n            fScore[nr][nc] = tentativeG + heuristic({ r: nr, c: nc }, end);\r\n            if (!inOpen[nr][nc]) {\r\n              openSet.push({ r: nr, c: nc });\r\n              inOpen[nr][nc] = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // reconstruct path\r\n    const path = [];\r\n    let cur = fScore[end.r][end.c] < Infinity ? end : null;\r\n    while (cur) {\r\n      path.unshift(cur);\r\n      cur = prev[cur.r]?.[cur.c];\r\n    }\r\n  \r\n    return { visitedOrder, path };\r\n  }\r\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}